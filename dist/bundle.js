/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 18);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vendors_illuminated__ = __webpack_require__(5);\n/* harmony export */ exports[\"a\"] = Sprite;\n\nconst { Vec2, PolygonObject } = __WEBPACK_IMPORTED_MODULE_1__vendors_illuminated__[\"a\" /* Illuminated */];\n\nfunction Sprite(\n  scene,\n  spritesheet,\n  x,\n  y,\n  width,\n  height,\n  frameWidth,\n  frameHeight,\n  animations = {\n    default: {\n      frames: [0],\n      loop: false,\n      speed: 0\n    }\n  }\n) {\n  let flipped = 1;\n  let currentAnimation;\n  let currentFrame;\n  let lastFrameAt;\n  setAnimation('default');\n  let speech;\n  let eraseSpeechAt;\n  let rotation = 0;\n  let image = new Image();\n  let loaded = false;\n  image.onload = function() {\n    loaded = true;\n\n    frameWidth = frameWidth || image.width;\n    frameHeight = frameHeight || image.height;\n  };\n\n  image.src = spritesheet;\n\n  const sprite = {\n    constructor: Sprite,\n    clickable: false,\n    move,\n    update,\n    render,\n    renderUI,\n    top,\n    right,\n    bottom,\n    left,\n    getX,\n    getY,\n    getCenterX,\n    getCenterY,\n    getWidth,\n    getHeight,\n    setCenterX,\n    setCenterY,\n    getCenterVector,\n    contains,\n    getOpaqueObject,\n    trigger,\n    copy,\n    destroy,\n    isEqual,\n    getSprite,\n    setFlipped,\n    overlaps,\n    setAnimation,\n    getAnimation,\n    getScene,\n    setSpeech,\n    getSpeech,\n    getRotation,\n    setRotation\n  };\n\n  return sprite;\n\n  function move(deltaX, deltaY) {\n    x += deltaX;\n    y += deltaY;\n  }\n\n  function update() {}\n\n  function render(context) {\n    if (!loaded) return;\n    context.save();\n    context.translate(x, y);\n    context.scale(flipped, 1);\n\n    let now = Date.now();\n    if (now - lastFrameAt > getCurrentAnimation().speed) {\n      lastFrameAt = now;\n\n      if (getCurrentAnimation().loop) {\n        currentFrame = (currentFrame + 1) % getCurrentAnimation().frames.length;\n      } else {\n        currentFrame += currentFrame + 1 >= getCurrentAnimation().frames.length ? 0 : 1;\n      }\n    }\n\n    let frameX = getCurrentAnimation().frames[currentFrame] * frameWidth;\n    console.log(this.constructor.name, frameX)\n\n    context.translate(frameWidth / 2, frameHeight / 2);\n    context.rotate(getRotation());\n    context.translate(-frameWidth / 2, -frameHeight / 2);\n    context.drawImage(image, frameX, 0, frameWidth, frameHeight, 0, 0, width * flipped, height);\n\n    if (window.DEBUG == true) {\n      context.beginPath();\n      context.lineWidth = \"1\";\n      context.strokeStyle = \"red\";\n      context.rect(0, 0, width * flipped, height);\n      context.stroke();\n    }\n    context.restore();\n  }\n\n  function renderUI(context) {\n    if (speech) {\n      if (Date.now() >= eraseSpeechAt) {\n        speech = undefined;\n        return;\n      }\n\n      context.save();\n      context.font = \"14px Monospace\";\n      context.shadowColor = \"black\";\n      context.shadowOffsetX = 1;\n      context.shadowOffsetY = 1;\n      context.fillStyle = \"bold\";\n      context.fillStyle = \"yellow\";\n      context.fillText(speech, getCenterX() - speech.length / 2 * 14, y - 50);\n      context.restore();\n    }\n  }\n\n  function getX() { return x; }\n  function getY() { return y; }\n  function getCenterX() { return getCenterVector().getX(); }\n  function getCenterY() { return getCenterVector().getY(); }\n  function getWidth() { return width; }\n  function getHeight() { return height; }\n\n  function setCenterX(centerX) {\n    x = centerX - width / 2;\n  }\n\n  function setCenterY(centerY) {\n    y = centerY - height / 2;\n  }\n\n  function getCenterVector() {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__[\"a\" /* Vector */])(getX() + width / 2, getY() + height / 2);\n  }\n\n  function left() { return getX(); }\n  function right() { return getX() + width; }\n  function top() { return getY(); }\n  function bottom() { return getY() + height; }\n\n  function contains(point) {\n    return point.x > left() && point.x < right() &&\n           point.y > top() && point.y < bottom();\n  }\n\n  // TODO: Calculate opaque object for shadow-casting\n  function getOpaqueObject() {\n    var from = new Vec2(left(), top());\n    var to = new Vec2(right(), bottom());\n    return new PolygonObject({ points: [from, to] });\n  }\n\n  function trigger() {}\n\n  function copy() {\n    return Sprite(scene, spritesheet, x, y, width, height);\n  }\n\n  function destroy() {\n    scene.remove(sprite);\n  }\n\n  function getSprite() {\n    return sprite;\n  }\n\n  function isEqual(object) {\n    return object.getSprite() == getSprite();\n  }\n\n  function setFlipped(newFlipped) {\n    flipped = newFlipped || flipped;\n  }\n\n  function overlaps(sprite) {\n    return !(sprite.right() < left() ||\n             sprite.left() > right() ||\n             sprite.bottom() < top() ||\n             sprite.top() > bottom());\n  }\n\n  function setAnimation(animation) {\n    currentAnimation = animation;\n    currentFrame = getCurrentAnimation() && getCurrentAnimation().frames[0];\n    lastFrameAt = Date.now();\n  }\n\n  function getAnimation() { return currentAnimation; }\n  function getCurrentAnimation() { return animations[currentAnimation]; }\n\n  function getScene() { return scene; }\n\n  function setSpeech(newSpeech, duration = 2000) {\n    speech = newSpeech;\n    eraseSpeechAt = Date.now() + duration;\n  }\n\n  function getSpeech() { return speech; }\n\n  function getRotation() { return rotation; }\n  function setRotation(degrees) {\n    rotation = degrees * Math.PI / 180;\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sprite.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./sprite.js?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony export */ exports[\"a\"] = Vector;function Vector(x, y) {\n  return {\n    getX,\n    getY,\n    magnitude,\n    normalize,\n    subtract,\n    add,\n    dotProduct,\n    toString\n  };\n\n  function getX() { return x; }\n  function getY() { return y; }\n\n  function magnitude() {\n    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  }\n\n  function normalize() {\n    if (magnitude() > 0) {\n      return Vector(x / magnitude(), y / magnitude());\n    }\n\n    return Vector(0, 0);\n  }\n\n  function subtract(vector) {\n    return Vector(x - vector.getX(), y - vector.getY());\n  }\n\n  function add(vector) {\n    return Vector(x + vector.getX(), y + vector.getY());\n  }\n\n  function dotProduct(scalar) {\n    return Vector(Math.round(x * scalar), Math.round(y * scalar));\n  }\n\n  function toString() {\n    return `(${x}, ${y})`;\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./vector.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./vector.js?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sprite__ = __webpack_require__(0);\n/* harmony export */ exports[\"a\"] = InventoryItem;\n\nfunction InventoryItem(sprite, onUse) {\n  let inventoryOffsetX = 100;\n  let inventoryOffsetY = 300;\n  let cellWidth = 100;\n  let cellHeight = 100;\n  let dragging = false;\n  let index;\n\n  let inventoryItem = Object.assign({}, sprite, {\n    constructor: InventoryItem,\n    clickable: true,\n    setIndex,\n    trigger,\n    isDragging,\n    getSprite\n  });\n\n  return inventoryItem;\n\n  function setIndex(newIndex) {\n    index = newIndex;\n    sprite.setCenterX(inventoryOffsetX + cellWidth * index + cellWidth / 2);\n    sprite.setCenterY(inventoryOffsetY + cellHeight / 2);\n  }\n\n  function trigger(eventType, coordinates) {\n    switch (eventType) {\n      case 'click':\n        dragging = true;\n        break;\n      case 'drop':\n        dragging = false;\n        setIndex(index);\n        onUse(inventoryItem, coordinates);\n        break;\n      case 'mousemove':\n        if (dragging) {\n          sprite.setCenterX(coordinates.x);\n          sprite.setCenterY(coordinates.y);\n        }\n        break;\n    }\n  }\n\n  function isDragging() { return dragging; }\n  function getSprite() { return sprite; }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./inventoryItem.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./inventoryItem.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sprite__ = __webpack_require__(0);\n/* harmony export */ exports[\"a\"] = Tree;\n\nfunction Tree(scene, lightSource, x, y) {\n  const tree = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sprite__[\"a\" /* Sprite */])(scene, './imgs/tree.png', x, y, 200, 300, 200, 300, {\n    dry: {\n      frames: [0],\n      speed: 0\n    },\n\n    burning: {\n      frames: [1, 2],\n      speed: 1000,\n      loop: true\n    }\n  });\n  tree.setAnimation('dry');\n\n  return Object.assign({}, tree, {\n    constructor: Tree,\n    name: 'Tree',\n    lightSource\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./tree.js\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./tree.js?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony export */ exports[\"a\"] = Trigger;function Trigger(sprite, onClick) {\n  const self = Object.assign({}, sprite, {\n    constructor: Trigger,\n    clickable: true,\n    trigger\n  });\n\n  return self;\n\n  function trigger(event) {\n    switch (event) {\n      case 'click': onClick(self);\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./trigger.js\n// module id = 4\n// module chunks = 0\n\n//# sourceURL=webpack:///./trigger.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/**\nIlluminated.js - A 2D lights and shadows rendering engine for HTML5\napplications and games.\n\n@module illuminated\n**/\n\n// Declare a root \"class\" for the static methods on the main namespace.\n/**\n@class illuminated\n**/\n\n/*\nCopyright (C) 2012 Gaëtan Renaudeau <renaudeau.gaetan@gmail.com>\nhttp://greweb.fr/illuminated.js/\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst Illuminated = (function(cp){\n  /**\n  Vec2 represents a 2d position or a 2d vector.\n  It is used everywhere in Illuminated.js.\n\n  Vec2 is based on Box2d’s Vec2 except that in Illuminated.js a Vec2\n  vector is immutable. It means every method creates a new Vec2 instance and\n  you can safely use a same Vec2 instance everywhere because the immutability\n  guarantees that properties will not be modified.\n\n  @class Vec2\n  @namespace illuminated\n  @constructor\n  @param {Number} [x=0] X coordinate for the vector.\n  @param {Number} [y=0] Y coordinate for the vector.\n  **/\n  cp.Vec2 = function (x, y) {\n    /**\n    X coordinate for the vector.\n    @property x\n    @type Number\n    @default 0\n    **/\n    this.x = x||0;\n\n    /**\n    Y coordinate for the vector.\n    @property y\n    @type Number\n    @default 0\n    **/\n    this.y = y||0;\n  }\n\n  /**\n  Returns a copy of this vector.\n  @method copy\n  @return {illuminated.Vec2} A new vector that is a copy of this vector.\n  **/\n  cp.Vec2.prototype.copy = function () {\n    return new cp.Vec2(this.x, this.y);\n  }\n\n  /**\n  Calculates the dot product of this vector and the given vector.\n  @method dot\n  @param {illuminated.Vec2} v A vector with which to calculate the dot product.\n  @return {Number} The result of the dot product.\n  **/\n  cp.Vec2.prototype.dot = function (v) {\n    return v.x*this.x + v.y*this.y;\n  }\n\n  /**\n  Subtracts the given vector from this vector.\n  @method sub\n  @param {illuminated.Vec2} v A vector to subtract from this vector.\n  @return {illuminated.Vec2} A new vector that is the result of the subtraction.\n  **/\n  cp.Vec2.prototype.sub = function (v) {\n    return new cp.Vec2(this.x-v.x, this.y-v.y);\n  }\n\n  /**\n  Adds the given vector to this vector.\n  @method add\n  @param {illuminated.Vec2} v A vector to add to this vector.\n  @return {illuminated.Vec2} A new vector that is the result of the addition.\n  **/\n  cp.Vec2.prototype.add = function (v) {\n    return new cp.Vec2(this.x+v.x, this.y+v.y);\n  }\n\n  /**\n  Multiplies the given vector with this vector.\n  @method mul\n  @param {illuminated.Vec2} v A vector to multiply with this vector.\n  @return {illuminated.Vec2} A new vector that is the result of the multiplication.\n  **/\n  cp.Vec2.prototype.mul = function (n) {\n    return new cp.Vec2(this.x*n, this.y*n);\n  }\n\n  /**\n  Returns the inverse of this vector.\n  @method inv\n  @return {illuminated.Vec2} A new vector that is the inverse of this vector.\n  **/\n  cp.Vec2.prototype.inv = function () {\n    return this.mul(-1);\n  }\n\n  /**\n  Calculates the squared distance between this vector and the given vector.\n  @method dist2\n  @param {illuminated.Vec2} v A vector with which the squared distance is calculated.\n  @return {Number} The squared distance.\n  **/\n  cp.Vec2.prototype.dist2 = function (v) {\n    var dx = this.x - v.x;\n    var dy = this.y - v.y;\n    return dx*dx + dy*dy;\n  }\n\n  /**\n  Calculates the normalized form of this vector.\n  @method normalize\n  @return {illuminated.Vec2} A new vector in normalized form.\n  **/\n  cp.Vec2.prototype.normalize = function () {\n    var length = Math.sqrt(this.length2());\n    return new cp.Vec2(this.x/length, this.y/length);\n  }\n\n  /**\n  Calculates the squared length of this vector.\n  @method length2\n  @return {Number} The squared length.\n  **/\n  cp.Vec2.prototype.length2 = function (v) {\n    return this.x*this.x + this.y*this.y;\n  }\n\n  /**\n  Returns a string representing this vector.\n  @method toString\n  @return {String} A string representing this vector.\n  **/\n  cp.Vec2.prototype.toString = function () {\n    return this.x+\",\"+this.y;\n  }\n\n\n  /**\n  Determines if this vector is within the bounds defined by the given vectors.\n  @method inBound\n  @param {illuminated.Vec2} topleft A vector that is the top-left of the bounds.\n  @param {illuminated.Vec2} bottomright A vector that is the bottom-right of the bounds.\n  @return {Boolean} True if this vector is within the given bounds.\n  **/\n  cp.Vec2.prototype.inBound = function (topleft, bottomright) {\n    return (topleft.x < this.x && this.x < bottomright.x\n         && topleft.y < this.y && this.y < bottomright.y);\n  }\n\n\n  /**\n  Abstract class for light objects.\n  @class Light\n  @constructor\n  @param {Object} [options] Options to be applied to this light.\n  @param {illuminated.Vec2} [options.position] Position of this light. (0,0) by default.\n  @param {Number} [options.distance=100] Intensity of this light.\n  @param {Number} [options.diffuse=0.8] How diffuse this light is.\n  **/\n  cp.Light = function (options) { extend(this, cp.Light.defaults, options);}\n\n  cp.Light.defaults = {\n    /**\n    Position of this light. (0,0) by default.\n    @property position\n    @type Vec2\n    @default new Vec2(0, 0)\n    **/\n    position: new cp.Vec2(),\n\n    /**\n    Intensity of this light.\n    @property distance\n    @type Number\n    @default 100\n    **/\n    distance: 100,\n\n    /**\n    How diffuse this light is.\n    @property diffuse\n    @type Number\n    @default 0.8\n    **/\n    diffuse: 0.8\n  };\n  \n  /**\n  Render the light onto the given context.\n  @method render\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the\n  light will be rendered.\n  **/\n  cp.Light.prototype.render = function (ctx) { }\n\n  /**\n  Render a mask representing the visibility. (Used by DarkMask.)\n  @method mask\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the mask\n  will be rendered.\n  **/\n  cp.Light.prototype.mask = function (ctx) {\n    var c = this._getVisibleMaskCache();\n    ctx.drawImage(\n      c.canvas,\n      Math.round(this.position.x-c.w/2),\n      Math.round(this.position.y-c.h/2)\n    );\n  }\n\n  /**\n  Calculate the boundaries of this light using the light's distance.\n  @method bounds\n  @return {Object} An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.Light.prototype.bounds = function () {\n    return {\n      topleft: new cp.Vec2(this.position.x-this.distance, this.position.y-this.distance),\n      bottomright: new cp.Vec2(this.position.x+this.distance, this.position.y+this.distance)\n    }\n  }\n  \n  /**\n  Return the center of this light.\n  i.e. The position where the light intensity is the highest\n  @method center\n  @return {illuminated.Vec2} A new vector that represents the center of this light.\n  **/\n  cp.Light.prototype.center = function () {\n    return new cp.Vec2( this.distance, this.distance );\n  }\n\n  /**\n  Invoke a function for every sample generated by this light.\n  @method forEachSample\n  @param {Function} f Function to be called for every sample. The function will\n  be passed a vector representing the position of the sample.\n  **/\n  // Implement it by spreading samples and calling f at each time\n  cp.Light.prototype.forEachSample = function (f) { f(this.position); }\n\n  /**\n  Creates a canvas context with the visible mask rendered onto it.\n  @private\n  @method _getVisibleMaskCache\n  @return {CanvasRenderingContext2D} A canvas context with the visible mask\n  rendered onto it.\n  **/\n  cp.Light.prototype._getVisibleMaskCache = function () {\n    // By default use a radial gradient based on the distance\n    var d = Math.floor(this.distance*1.4);\n    var hash = \"\"+d;\n    if (this.vismaskhash != hash) {\n      this.vismaskhash = hash;\n      var c = this._vismaskcache = createCanvasAnd2dContext('vm'+this.id, 2*d, 2*d);\n      var g = c.ctx.createRadialGradient(d, d, 0, d, d, d);\n      g.addColorStop( 0, 'rgba(0,0,0,1)' );\n      g.addColorStop( 1, 'rgba(0,0,0,0)' );\n      c.ctx.fillStyle = g;\n      c.ctx.fillRect(0, 0, c.w, c.h);\n    }\n    return this._vismaskcache;\n  }\n\n  /**\n  Return a string hash key representing this lamp.\n  @private\n  @method _getHashCache\n  @return {String} The hash key.\n  **/\n  cp.Light.prototype._getHashCache = function () {\n    return [this.distance, this.diffuse].toString();\n  }\n\n\n  /**\n  Abstract class for opaque objects.\n  @class OpaqueObject\n  @constructor\n  @param {Object} [options] Options to be applied to this opaque object.\n  @param {Number} [options.diffuse] How diffuse this opaque object should be.\n  **/\n  cp.OpaqueObject = function (options) { extend(this, cp.OpaqueObject.defaults, options); }\n\n  cp.OpaqueObject.defaults = {\n    /**\n    How diffuse this opaque object should be.\n    @property diffuse\n    @type Number\n    @default 0.8\n    **/\n    diffuse: 0.8\n  };\n\n  cp.OpaqueObject.uniqueId = 0;\n\n  /**\n  Fill ctx with the shadows projected by this opaque object at the origin\n  point, constrained by the given bounds.\n  @method cast\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the\n  shadows will be cast.\n  @param {illuminated.Vec2} origin A vector that represents the origin for the casted shadows.\n  @param {Object} bounds An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.OpaqueObject.prototype.cast = function (ctx, origin, bounds) { }\n\n  /**\n  Draw the path of the opaque object shape onto the ctx.\n  @method path\n  @param {CanvasRenderingContext2D} ctx The context onto which the path will be\n  drawn.\n  **/\n  cp.OpaqueObject.prototype.path = function (ctx) { }\n\n  /**\n  Calculate the boundaries of this opaque object.\n  @method bounds\n  @return {Object} An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.OpaqueObject.prototype.bounds = function () { return { topleft: new cp.Vec2(), bottomright: new cp.Vec2() } }\n\n  /**\n  Determine if the given point is inside the object.\n  @method contains\n  @param {illuminated.Vec2} point The point to be checked.\n  @return {Boolean} True if the opaque object contains the given point.\n  **/\n  cp.OpaqueObject.prototype.contains = function (point) { return false }\n\n\n  // LIGHTS\n\n  /**\n  A circular light rendered as a radial gradient. Lamps can also be \"oriented\"\n  in a specific direction.\n  @class Lamp\n  @extends illuminated.Light\n  @constructor\n  @example\n      new Lamp({\n        position: new Vec2(12, 34),\n        distance: 100,\n        diffuse: 0.8,\n        color: 'rgba(250,220,150,0.8)',\n        radius: 0,\n        samples: 1,\n        angle: 0,\n        roughness: 0\n      })\n  @param {Object} [options] Options to be applied to this lamp.\n  @param {illuminated.Vec2} [options.position] Position of this lamp. (0,0) by default.\n  @param {Number} [options.distance=100] Intensity of this lamp.\n  @param {Number} [options.diffuse=0.8] How diffuse this lamp is.\n  @param {String} [options.color='rgba(250,220,150,0.8)'] The color emitted by\n  the lamp. The color can be specified in any CSS format.\n  @param {Number} [options.radius=0] The size of the lamp. Bigger lamps cast\n  smoother shadows.\n  @param {Number} [options.samples=1] The number of points which will be used\n  for shadow projection. It defines the quality of the rendering.\n  @param {Number} [options.angle=0] The angle of the orientation of the lamp.\n  @param {Number} [options.roughness=0] The roughness of the oriented effect.\n  **/\n  cp.Lamp = function (options) { extend(this, cp.Light.defaults, cp.Lamp.defaults, options);\n    if(this.id===0){this.id=++cp.Lamp.uniqueId} }\n  inherit(cp.Lamp, cp.Light);\n\n  cp.Lamp.defaults = {\n    /**\n     * The id of this light object.\n     * @property id\n     * @type Number\n     * @default 0\n     */\n    id: 0,\n\n    /**\n    The color emitted by the lamp. The color can be specified in any CSS format.\n    @property color\n    @type String\n    @default 'rgba(250,220,150,0.8)'\n    **/\n    color: 'rgba(250,220,150,0.8)',\n\n    /**\n    The size of the lamp. Bigger lamps cast smoother shadows.\n    @property radius\n    @type Number\n    @default 0\n    **/\n    radius: 0,\n\n    /**\n    The number of points which will be used for shadow projection. It defines\n    the quality of the rendering.\n    @property samples\n    @type Number\n    @default 1\n    **/\n    samples: 1,\n\n    /**\n    The angle of the orientation of the lamp.\n    @property angle\n    @type Number\n    @default 0\n    **/\n    angle: 0,\n\n    /**\n    The roughness of the oriented effect.\n    @property roughness\n    @type Number\n    @default 0\n    **/\n    roughness: 0\n  };\n\n  cp.Lamp.uniqueId = 0;\n\n  /**\n  Return a string hash key representing this lamp.\n  @private\n  @method _getHashCache\n  @return {String} The hash key.\n  **/\n  cp.Lamp.prototype._getHashCache = function () {\n    return [this.color, this.distance, this.diffuse, this.angle, this.roughness, this.samples, this.radius].toString();\n  }\n\n  /**\n  Return the center of this lamp.\n  i.e. The position where the lamp intensity is the highest\n  @method center\n  @return {illuminated.Vec2} A new vector that represents the center of this lamp.\n  **/\n  cp.Lamp.prototype.center = function () {\n    return new cp.Vec2( (1-Math.cos(this.angle)*this.roughness)*this.distance, (1+Math.sin(this.angle)*this.roughness)*this.distance );\n  }\n\n  /**\n  Calculate the boundaries of this lamp based on its properties.\n  @method bounds\n  @return {Object} An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.Light.prototype.bounds = function () {\n    var orientationCenter = new cp.Vec2(Math.cos(this.angle), -Math.sin(this.angle)).mul(this.roughness*this.distance);\n    return {\n      topleft: new cp.Vec2(this.position.x+orientationCenter.x-this.distance, this.position.y+orientationCenter.y-this.distance),\n      bottomright: new cp.Vec2(this.position.x+orientationCenter.x+this.distance, this.position.y+orientationCenter.y+this.distance)\n    }\n  }\n\n  /**\n  Render a mask representing the visibility. (Used by DarkMask.)\n  @method mask\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the mask\n  will be rendered.\n  **/\n  cp.Lamp.prototype.mask = function (ctx) {\n    var c = this._getVisibleMaskCache();\n    var orientationCenter = new cp.Vec2(Math.cos(this.angle), -Math.sin(this.angle)).mul(this.roughness*this.distance);\n    ctx.drawImage(c.canvas, Math.round(this.position.x+orientationCenter.x-c.w/2), Math.round(this.position.y+orientationCenter.y-c.h/2));\n  }\n\n  /**\n  Renders this lamp's gradient onto a cached canvas at the given position.\n  @private\n  @method _getGradientCache\n  @param {illuminated.Vec2} center The position of the center of the gradient to render.\n  **/\n  cp.Lamp.prototype._getGradientCache = function (center) {\n    var hashcode = this._getHashCache();\n    if (this._cacheHashcode == hashcode) {\n      return this._gcache;\n    }\n    this._cacheHashcode = hashcode;\n    var d = Math.round(this.distance);\n    var D = d*2;\n    var cache = createCanvasAnd2dContext('gc'+this.id, D, D);\n    var g = cache.ctx.createRadialGradient(center.x, center.y, 0, d, d, d);\n    g.addColorStop( Math.min(1,this.radius/this.distance), this.color );\n    g.addColorStop( 1, cp.getRGBA(this.color, 0) );\n    cache.ctx.fillStyle = g;\n    cache.ctx.fillRect(0, 0, cache.w, cache.h);\n    return this._gcache = cache;\n  }\n\n  /**\n  Render the lamp onto the given context (without any shadows).\n  @method render\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the\n  light will be rendered.\n  **/\n  cp.Lamp.prototype.render = function (ctx) {\n    var center = this.center();\n    var c = this._getGradientCache(center);\n    ctx.drawImage(c.canvas, Math.round(this.position.x-center.x), Math.round(this.position.y-center.y))\n  }\n\n  /**\n  Invoke a function for every sample generated by this lamp. The samples for\n  lamps are generated using a \"spiral\" algorithm.\n  @method forEachSample\n  @param {Function} f Function to be called for every sample. The function will\n  be passed a vector representing the position of the sample.\n  **/\n  cp.Lamp.prototype.forEachSample = function (f) {\n    // \"spiral\" algorithm for spreading emit samples\n    for (var s=0, l=this.samples; s<l; ++s) {\n      var a = s * GOLDEN_ANGLE;\n      var r = Math.sqrt(s/this.samples)*this.radius;\n      var delta = new cp.Vec2( Math.cos(a)*r, Math.sin(a)*r );\n      f( this.position.add(delta) );\n    }\n  }\n\n  /*\n   * Spot\n   * TODO\n   */\n  /*\n  cp.Spot = function (position, distance) {\n    this.position = position;\n    this.distance = position;\n  }\n  inherit(cp.Spot, cp.Light);\n  */\n\n  /*\n   * Neon\n   * TODO\n   */\n  /*\n  cp.Neon = function (position, distance, color, size, samples, angle) {\n    this.position = position;\n    this.distance = distance;\n    this.color = color;\n    this.size = size || 10;\n    this.samples = samples || 2;\n    this.angle = angle || 0;\n  }\n  inherit(cp.Neon, cp.Light);\n\n  // TODO .center() and .bound()\n\n  cp.Neon.prototype.render = function (ctx) {\n    var center = this.center();\n    var c = this._getGradientCache(center);\n    ctx.drawImage(c.canvas, Math.round(this.position.x-center.x), Math.round(this.position.y-center.y))\n  }\n\n  cp.Neon.prototype._getHashCache = function () {\n    return [this.color, this.distance, this.angle].toString();\n  }\n\n  cp.Neon.prototype._getGradientCache = function (center) {\n    var hashcode = this._getHashCache();\n    if (this.cacheHashcode == hashcode) {\n      return this.gradientCache;\n    }\n    this.cacheHashcode = hashcode;\n    var d = Math.round(this.distance);\n    var D = d*2;\n    var cache = createCanvasAnd2dContext(D, D);\n    var g = cache.ctx.createRadialGradient(center.x, center.y, 0, d, d, d);\n    g.addColorStop( 0, this.color );\n    g.addColorStop( 1, 'rgba(0,0,0,0)' );\n    cache.ctx.fillStyle = g;\n    cache.ctx.fillRect(0, 0, cache.w, cache.h);\n    return this.gradientCache = cache;\n  }\n  */\n\n  /*\n   * OrientedNeon: Neon with one side\n   * TODO\n   */\n  /*\n  cp.OrientedNeon = function (position, distance) {\n    this.position = position;\n    this.distance = position;\n  }\n  inherit(cp.OrientedNeon, cp.Light);\n  */\n\n  /* Get tangents from (0,0) to circle of radius with given center, for cp.DiscObject.prototype.cast. */\n  function getTan2(radius, center) {\n    var epsilon = getTan2.epsilon || 1e-6, // constant\n        x0, y0, len2, soln, \n        solutions=[], a=radius;\n    if (typeof a === \"object\" && typeof center === \"number\") { \n      var tmp=a; center = a; center = tmp; // swap\n    }\n    if (typeof center === \"number\") {\n        // getTan2(radius:number, x0:number, y0:number)\n        x0 = center;\n        y0 = arguments[2];\n        len2 = x0*x0 + y0*y0;\n    } else {\n        // getTans2(radius:number, center:object={x:x0,y:y0})\n        x0 = center.x;\n        y0 = center.y;\n        len2 = center.length2();\n    }\n    // t = +/- Math.acos( (-a*x0 +/- y0 * Math.sqrt(x0*x0 + y0*y0 - a*a))/(x0*x0 + y0*y) );\n    var len2a = y0 * Math.sqrt(len2 - a*a), \n        tt = Math.acos( (-a*x0 + len2a) / len2 ),\n        nt = Math.acos( (-a*x0 - len2a) / len2 ),\n        tt_cos = a*Math.cos(tt),\n        tt_sin = a*Math.sin(tt),\n        nt_cos = a*Math.cos(nt),\n        nt_sin = a*Math.sin(nt);\n    \n    // Note: cos(-t) == cos(t) and sin(-t) == -sin(t) for all t, so find\n    // x0 + a*cos(t), y0 +/- a*sin(t)\n    // Solutions have equal lengths\n    soln = new cp.Vec2(x0 + nt_cos, y0 + nt_sin);\n    solutions.push(soln);\n    var dist0 = soln.length2();\n    \n    soln = new cp.Vec2(x0 + tt_cos, y0 - tt_sin);\n    solutions.push(soln);\n    var dist1 = soln.length2();\n    if ( Math.abs(dist0 - dist1) < epsilon ) return solutions;\n    \n    soln = new cp.Vec2(x0 + nt_cos, y0 - nt_sin);\n    solutions.push(soln);\n    var dist2 = soln.length2();\n    // Changed order so no strange X of light inside the circle. Could also sort results.\n    if ( Math.abs(dist1 - dist2) < epsilon ) return [soln, solutions[1]]; \n    if ( Math.abs(dist0 - dist2) < epsilon ) return [solutions[0], soln];\n    \n    soln = new cp.Vec2(x0 + tt_cos, y0 + tt_sin);\n    solutions.push(soln);\n    var dist3 = soln.length2();\n    if ( Math.abs(dist2 - dist3) < epsilon ) return [solutions[2], soln];\n    if ( Math.abs(dist1 - dist3) < epsilon ) return [solutions[1], soln];\n    if ( Math.abs(dist0 - dist3) < epsilon ) return [solutions[0], soln];\n    \n    // return all 4 solutions if no matching vector lengths found.\n    return solutions;\n  }\n  \n  // OBJECTS\n\n  /**\n  A circular, opaque object.\n  @class DiscObject\n  @extends illuminated.OpaqueObject\n  @constructor\n  @param {Object} [options] Options to be applied to this disc object.\n  @param {illuminated.Vec2} [options.center] Position of the disc object.\n  @param {Number} [options.radius] Size of the disc object.\n  @param {Number} [options.diffuse] How diffuse this disc object should be.\n  **/\n  cp.DiscObject = function (options) { extend(this, cp.OpaqueObject.defaults, cp.DiscObject.defaults, options); }\n  inherit(cp.DiscObject, cp.OpaqueObject);\n\n  cp.DiscObject.defaults = {\n    /**\n    Position of the disc object.\n    @property center\n    @type Vec2\n    @default new illuminated.Vec2()\n    **/\n    center: new cp.Vec2(),\n\n    /**\n    Size of the disc object.\n    @property radius\n    @type Number\n    @default 20\n    **/\n    radius: 20\n  };\n\n  /**\n  Fill ctx with the shadows projected by this disc object from the origin\n  point, constrained by the given bounds.\n  @method cast\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the\n  shadows will be cast.\n  @param {illuminated.Vec2} origin A vector that represents the origin for the casted shadows.\n  @param {Object} bounds An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.DiscObject.prototype.cast = function (ctx, origin, bounds) {\n    var m = this.center;\n    var originToM = m.sub(origin);\n\n    // FIXED: this method was wrong... TODO must see http://en.wikipedia.org/wiki/Tangent_lines_to_circles\n    // var d = new cp.Vec2(originToM.y, -originToM.x).normalize().mul(this.radius);\n    \n    // var a = this.center.add(d);\n    // var b = this.center.add(d.inv());\n\n    // var originToA = a.sub(origin);\n    // var originToB = b.sub(origin);\n    \n    var tangentLines = getTan2(this.radius, originToM);\n    var originToA = tangentLines[0];\n    var originToB = tangentLines[1];\n    var a = originToA.add(origin);\n    var b = originToB.add(origin);\n\n    // normalize to distance\n    var distance = ((bounds.bottomright.x-bounds.topleft.x)+(bounds.bottomright.y-bounds.topleft.y))/2;\n    originToM = originToM.normalize().mul(distance);\n    originToA = originToA.normalize().mul(distance);\n    originToB = originToB.normalize().mul(distance);\n    \n    // project points\n    var oam = a.add(originToM);\n    var obm = b.add(originToM);\n    var ap = a.add(originToA);\n    var bp = b.add(originToB);\n\n    var start = Math.atan2(originToM.x, -originToM.y);\n    ctx.beginPath();\n    path(ctx, [b, bp, obm, oam, ap, a], true);\n    ctx.arc(m.x, m.y, this.radius, start, start+Math.PI);\n    ctx.fill();\n  }\n\n  /**\n  Draw the path of the disc onto the ctx.\n  @method path\n  @param {CanvasRenderingContext2D} ctx The context onto which the path will be\n  drawn.\n  **/\n  cp.DiscObject.prototype.path = function (ctx) {\n    ctx.arc(this.center.x, this.center.y, this.radius, 0, _2PI);\n  }\n  \n  /**\n  Calculate the boundaries of this disc object.\n  @method bounds\n  @return {Object} An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.DiscObject.prototype.bounds = function () { \n    return { \n      topleft: new cp.Vec2(this.center.x-this.radius, this.center.y-this.radius),\n      bottomright: new cp.Vec2(this.center.x+this.radius, this.center.y+this.radius)\n    } \n  }\n  \n  /**\n  Determine if the given point is inside the disc.\n  @method contains\n  @param {illuminated.Vec2} point The point to be checked.\n  @return {Boolean} True if the disc object contains the given point.\n  **/\n  cp.DiscObject.prototype.contains = function (point) { \n    return point.dist2(this.center) < this.radius*this.radius;\n  }\n\n  /**\n  An opaque polygon object\n  @class PolygonObject\n  @extends illuminated.OpaqueObject\n  @constructor\n  @param {Object} [options] Options to be applied to this disc object.\n  @param {Array} options.points An array of\n  {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} points that define the polygon.\n  @param {Number} [options.diffuse] How diffuse this polygon object should be.\n  **/\n  cp.PolygonObject = function (options) { extend(this, cp.OpaqueObject.defaults, cp.PolygonObject.defaults, options); }\n  inherit(cp.PolygonObject, cp.OpaqueObject);\n\n  cp.PolygonObject.defaults = {\n    /**\n    An array of {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} points that\n    define the polygon.\n    @property points\n    @type Array\n    @default []\n    **/\n    points: []\n  };\n\n  /**\n  Calculate the boundaries of this polygon object.\n  @method bounds\n  @return {Object} An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.PolygonObject.prototype.bounds = function () {\n    var topleft = this.points[0].copy();\n    var bottomright = topleft.copy();\n    for (var p=1, l=this.points.length; p<l; ++p) {\n      var point = this.points[p];\n      if (point.x > bottomright.x)\n        bottomright.x = point.x;\n      if (point.y > bottomright.y)\n        bottomright.y = point.y;\n      if (point.x < topleft.x)\n        topleft.x = point.x;\n      if (point.y < topleft.y)\n        topleft.y = point.y;\n    }\n    return { topleft: topleft, bottomright: bottomright };\n  }\n\n  /**\n  Determine if the given point is inside the polygon.\n  @method contains\n  @param {illuminated.Vec2} point The point to be checked.\n  @return {Boolean} True if the polygon object contains the given point.\n  **/\n  cp.PolygonObject.prototype.contains = function (p) {\n    var points = this.points;\n    var i, l=points.length, j=l-1;\n    var x = p.x, y = p.y;\n    var oddNodes = false;\n\n    for (i=0; i<l; i++) {\n      if ((points[i].y< y && points[j].y>=y\n      ||   points[j].y< y && points[i].y>=y)\n      &&  (points[i].x<=x || points[j].x<=x)) {\n        if (points[i].x+(y-points[i].y)/(points[j].y-points[i].y)*(points[j].x-points[i].x)<x) {\n          oddNodes=!oddNodes; \n        }\n      }\n      j=i; \n    }\n    return oddNodes;\n  }\n\n  /**\n  Draw the path of the polygon onto the ctx.\n  @method path\n  @param {CanvasRenderingContext2D} ctx The context onto which the path will be\n  drawn.\n  **/\n  cp.PolygonObject.prototype.path = function (ctx) {\n    path(ctx, this.points);\n  }\n\n  /**\n  Fill ctx with the shadows projected by this polygon object from the origin\n  point, constrained by the given bounds.\n  @method cast\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the\n  shadows will be cast.\n  @param {illuminated.Vec2} origin A vector that represents the origin for the casted shadows.\n  @param {Object} bounds An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary.\n  **/\n  cp.PolygonObject.prototype.cast = function (ctx, origin, bounds) {\n    // The current implementation of projection is a bit hacky... do you have a proper solution?\n    var distance = ((bounds.bottomright.x-bounds.topleft.x)+(bounds.bottomright.y-bounds.topleft.y))/2;\n    this._forEachVisibleEdges(origin, bounds, function (a, b, originToA, originToB, aToB) {\n      var m; // m is the projected point of origin to [a, b]\n      var t = originToA.inv().dot(aToB)/aToB.length2();\n      if (t<0)\n        m = a;\n      else if(t>1)\n        m = b;\n      else\n        m = a.add( aToB.mul(t) );\n      var originToM = m.sub(origin);\n      // normalize to distance\n      originToM = originToM.normalize().mul(distance);\n      originToA = originToA.normalize().mul(distance);\n      originToB = originToB.normalize().mul(distance);\n      // project points\n      var oam = a.add(originToM);\n      var obm = b.add(originToM);\n      var ap = a.add(originToA);\n      var bp = b.add(originToB);\n      ctx.beginPath();\n      path(ctx, [a, b, bp, obm, oam, ap]);\n      ctx.fill();\n    });\n  }\n\n\n  /**\n  Invoke a function for each of the visible edges in this polygon.\n  @private\n  @method _forEachVisibleEdges\n  @param {illuminated.Vec2} origin A vector that represents the origin for the casted shadows.\n  @param {Object} bounds An anonymous object with the properties topleft and\n  bottomright. The property values are {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects representing the corners\n  of the boundary of this polygon.\n  @param {Function} f The function to be invoked.\n  **/\n  cp.PolygonObject.prototype._forEachVisibleEdges = function (origin, bounds, f) {\n    var a = this.points[this.points.length-1], b;\n    for (var p=0, l=this.points.length; p<l; ++p, a=b) {\n      b = this.points[p];\n      if (a.inBound(bounds.topleft, bounds.bottomright)) {\n         var originToA = a.sub(origin);\n         var originToB = b.sub(origin);\n         var aToB = b.sub(a);\n         var normal = new cp.Vec2(aToB.y, -aToB.x);\n         if (normal.dot(originToA) < 0) {\n           f(a, b, originToA, originToB, aToB);\n         }\n       }\n    }\n  }\n\n  /**\n  A rectangular, opqaue object.\n  @class RectangleObject\n  @extends illuminated.PolygonObject\n  @constructor\n  @param {Object} [options] Options to be applied to this rectangle object.\n  @param {illuminated.Vec2} [options.topleft] A vector that is the top-left of the rectangle.\n  @param {illuminated.Vec2} [options.bottomright] A vector that is the bottom-right of the rectangle.\n  **/\n  cp.RectangleObject = function (options) {\n    extend(this, cp.OpaqueObject.defaults, cp.PolygonObject.defaults, cp.RectangleObject.defaults, options);\n    this.syncFromTopleftBottomright();\n  }\n  inherit(cp.RectangleObject, cp.PolygonObject);\n\n  cp.RectangleObject.defaults = {\n    /**\n    A vector that is the top-left of the rectangle.\n    @property topleft\n    @type Vec2\n    @default new illuminated.Vec2()\n    **/\n    topleft: new cp.Vec2(),\n    \n    /**\n    A vector that is the bottom-right of the rectangle.\n    @property bottomright\n    @type Vec2\n    @default new illuminated.Vec2()\n    **/\n    bottomright: new cp.Vec2()\n  };\n\n  /**\n  Initializes the points defining this rectangle based on its specified bounds.\n  @private\n  @method syncFromTopleftBottomright\n  **/\n  cp.RectangleObject.prototype.syncFromTopleftBottomright = function () {\n    var a = this.topleft;\n    var b = new cp.Vec2(this.bottomright.x, this.topleft.y);\n    var c = this.bottomright;\n    var d = new cp.Vec2(this.topleft.x, this.bottomright.y);\n    this.points = [a, b, c, d];\n  }\n\n  /**\n  Draws this rectangle onto the given context\n  @method fill\n  @param {CanvasRenderingContext2D} ctx The canvas context onto which the\n  rectangle should be drawn.\n  **/\n  cp.RectangleObject.prototype.fill = function (ctx) {\n    var x = this.points[0].x, y = this.points[0].y;\n    ctx.rect(x, y, this.points[2].x-x, this.points[2].y-y);\n  }\n\n  /**\n  An opaque line object\n  @class LineObject\n  @extends illuminated.PolygonObject\n  @constructor\n  @param {Object} [options] Options to be applied to this line object.\n  @param {illuminated.Vec2} [options.a] A vector that is the first point of the line.\n  @param {illuminated.Vec2} [options.b] A vector that is the last point of the line.\n  **/\n  cp.LineObject = function (options) {\n    extend(this, cp.OpaqueObject.defaults, cp.PolygonObject.defaults, cp.LineObject.defaults, options);\n    this.syncFromAB();\n  }\n  inherit(cp.LineObject, cp.PolygonObject);\n\n  cp.LineObject.defaults = {\n    /**\n    A vector that is the first point of the line.\n    @property a\n    @type Vec2\n    @default new illuminated.Vec2()\n    **/\n    a: new cp.Vec2(),\n\n    /**\n    A vector that is the last point of the line.\n    @property b\n    @type Vec2\n    @default new illuminated.Vec2()\n    **/\n    b: new cp.Vec2()\n  };\n\n  /**\n  Initializes the points defining this line based on its options.\n  @private\n  @method syncFromAB\n  **/\n  cp.LineObject.prototype.syncFromAB = function () {\n    this.points = [this.a, this.b];\n  }\n\n  /**\n  Defines the lighting of one light through a set of opaque objects.\n  @class Lighting \n  @constructor\n  @param {Object} [options] Options to be applied to this light.\n  @param {illuminated.Light} [options.light] The source of the lighting.\n  @param {Array} [options.objects] An array of \n  {{#crossLink \"illuminated.OpaqueObject\"}}{{/crossLink}} objects which stop the\n  light and create shadows.\n  **/\n  cp.Lighting = function (opts) {\n    extend(this, cp.Lighting.defaults, opts);\n  }\n\n  cp.Lighting.defaults = {\n    /**\n    The source of the lighting.\n    @property light\n    @type Light\n    @default new illuminated.Light()\n    **/\n    light: new cp.Light(),\n\n    /**\n    An array of {{#crossLink \"illuminated.OpaqueObject\"}}{{/crossLink}} objects\n    which stop the light and create shadows.\n    @property objects\n    @type Array\n    @default []\n    **/\n    objects: []\n  }\n\n  /**\n  Create caches for canvas contexts.\n  @private\n  @method createCache\n  @param {Number} w Width of the contexts.\n  @param {Number} h Height of the contexts.\n  **/\n  cp.Lighting.prototype.createCache = function (w, h) {\n    this._cache = createCanvasAnd2dContext('lc', w,h);\n    this._castcache = createCanvasAnd2dContext('lcc', w,h);\n  }\n\n  /**\n  Draw the shadows that are cast by the objects. You usually don't have to use\n  it if you use render().\n  @method cast\n  @param {CanvasRenderingContext2D} ctxoutput The canvas context onto which the\n  shadows will be drawn.\n  **/\n  cp.Lighting.prototype.cast = function (ctxoutput) {\n    var light = this.light;\n    var n = light.samples;\n    var c = this._castcache;\n    var ctx = c.ctx;\n    ctx.clearRect(0, 0, c.w, c.h);\n    // Draw shadows for each light sample and objects\n    ctx.fillStyle = \"rgba(0,0,0,\"+Math.round(100/n)/100+\")\"; // Is there any better way?\n    var bounds = light.bounds();\n    var objects = this.objects;\n    light.forEachSample(function (position) {\n      var sampleInObject = false;\n      for (var o=0, l=objects.length; o<l; ++o) {\n        if (objects[o].contains(position)) {\n          ctx.fillRect(bounds.topleft.x, bounds.topleft.y, bounds.bottomright.x-bounds.topleft.x, bounds.bottomright.y-bounds.topleft.y);\n          return;\n        }\n      }\n      objects.forEach(function(object) {\n        object.cast(ctx, position, bounds);\n      });\n    });\n    // Draw objects diffuse - the intensity of the light penetration in objects\n    objects.forEach(function(object) {\n      var diffuse = object.diffuse===undefined ? 0.8 : object.diffuse;\n      diffuse *= light.diffuse;\n      ctx.fillStyle = \"rgba(0,0,0,\"+(1-diffuse)+\")\";\n      ctx.beginPath();\n      object.path(ctx);\n      ctx.fill();\n    });\n    ctxoutput.drawImage(c.canvas, 0, 0);\n  }\n\n  /**\n  Compute the shadows to cast.\n  @method compute\n  @param {Number} w Width of the canvas context.\n  @param {Number} h Height of the canvas context.\n  **/\n  cp.Lighting.prototype.compute = function (w,h) {\n    if (!this._cache || this._cache.w != w || this._cache.h != h)\n      this.createCache(w, h);\n    var ctx = this._cache.ctx;\n    var light = this.light;\n    ctx.save();\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    \n    light.render(ctx);\n    ctx.globalCompositeOperation = \"destination-out\";\n    this.cast(ctx);\n    ctx.restore();\n  }\n\n  /**\n  Draws the light and shadows onto the given context.\n  @method render\n  @param {CanvasRenderingContext2D} ctx The canvas context on which to draw.\n  **/\n  cp.Lighting.prototype.render = function (ctx) {\n    ctx.drawImage(this._cache.canvas, 0, 0);\n  }\n\n  /**\n  Returns the light and shadows onto the given context as canvas.\n  @method render\n  @return {Canvas} The picture of the light and shadow.\n  **/\n  cp.Lighting.prototype.getCanvas = function () {\n    return this._cache.canvas;\n  }\n\n  /**\n  Defines the dark layer which hides the dark area not illuminated by a set of\n  lights.\n  @class DarkMask\n  @constructor\n  @param {Object} [options] Options to be applied to this light.\n  @param {Array} [options.lights] An array of\n  {{#crossLink \"illuminated.Light\"}}{{/crossLink}} objects that illuminate the\n  rest of the scene.\n  @param {String} [options.color] The color of the dark area in RGBA format.\n  **/\n  cp.DarkMask = function (options) {\n    extend(this, cp.DarkMask.defaults, options);\n  }\n\n  cp.DarkMask.defaults = {\n    /**\n    An array of {{#crossLink \"illuminated.Light\"}}{{/crossLink}} objects that\n    illuminate the rest of the scene.\n    @property lights\n    @type Array\n    @default []\n    **/\n    lights: [],\n\n    /**\n    The color of the dark area in RGBA format.\n    @property color\n    @type String\n    @default 'rgba(0,0,0,0.9)'\n    **/\n    color: 'rgba(0,0,0,0.9)'\n  }\n\n  /**\n  Compute the dark mask.\n  @method compute\n  @param {Number} w Width of the canvas context.\n  @param {Number} h Height of the canvas context.\n  **/\n  cp.DarkMask.prototype.compute = function (w,h) {\n    if (!this._cache || this._cache.w != w || this._cache.h != h)\n      this._cache = createCanvasAnd2dContext('dm', w,h);\n    var ctx = this._cache.ctx;\n    ctx.save();\n    ctx.clearRect(0, 0, w, h);\n    ctx.fillStyle = this.color;\n    ctx.fillRect(0, 0, w, h);\n    ctx.globalCompositeOperation = \"destination-out\";\n    this.lights.forEach(function(light){\n      light.mask(ctx);\n    });\n    ctx.restore();\n  }\n\n  /**\n  Draws the dark mask onto the given context.\n  @method render\n  @param {CanvasRenderingContext2D} ctx The canvas context on which to draw.\n  **/\n  cp.DarkMask.prototype.render = function (ctx) {\n    ctx.drawImage(this._cache.canvas, 0, 0);\n  }\n\n  /**\n  Gives the dark mask back.\n  @method render\n  @return {CanvasRenderingContext2D} The canvas context.\n  **/\n  cp.DarkMask.prototype.getCanvas = function (ctx) {\n    return this._cache.canvas;\n  }  \n\n   // UTILS & CONSTANTS\n\n  var GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));\n  var _2PI = 2*Math.PI;\n  \n  /**\n  @class illuminated\n  **/\n\n  /**\n  Creates a canvas and context with the given width and height.\n  @static\n  @method createCanvasAnd2dContext\n  @for illuminated\n  @param {Number} w Width of the canvas context.\n  @param {Number} h Height of the canvas context.\n  @return {Object} An anonymous object with \"canvas\", \"ctx\", \"w\" and \"h\"\n  properties.\n  **/\n  function createCanvasAnd2dContext (id, w, h) {\n    var iid = 'illujs_'+id;\n    var canvas = document.getElementById(iid);\n\n    if(canvas === null) {\n      var canvas = document.createElement(\"canvas\");\n      canvas.id = iid;\n      canvas.width = w;\n      canvas.height = h;\n      canvas.style.display = 'none';\n      document.body.appendChild(canvas);\n    }\n\n    var ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    canvas.width = w;\n    canvas.height = h;\n\n    return { canvas: canvas, ctx: ctx, w: w, h: h };\n  }\n  cp.createCanvasAnd2dContext = createCanvasAnd2dContext;\n\n  /**\n  Draw a path defined by the given points onto the given ctx.\n  @static\n  @method path\n  @param {CanvasRenderingContext2D} ctx The context onto which the properties\n  should be drawn.\n  @param {Array} points An array of\n  {{#crossLink \"illuminated.Vec2\"}}{{/crossLink}} objects that define the path.\n  @param {Boolean} dontJoinLast True if the last point should joined with the\n  first point in the path.\n  **/\n  function path (ctx, points, dontJoinLast) {\n    var p = points[0];\n    ctx.moveTo(p.x, p.y);\n    for (var i=1, l=points.length; i<l; ++i) {\n      p = points[i];\n      ctx.lineTo(p.x, p.y);\n    }\n    if (!dontJoinLast && points.length>2) {\n      p = points[0];\n      ctx.lineTo(p.x, p.y);\n    }\n  }\n  cp.path = path;\n\n  /**\n  Converts a CSS color string into RGBA format.\n  @static \n  @method getRGBA\n  @param {String} color Color in any CSS format.\n  @param {Number} alpha Alpha value for produced color.\n  @return {String} Color in RGBA format.\n  **/\n  var getRGBA = cp.getRGBA = (function(){\n    //var ctx = createCanvasAnd2dContext('grgba', 1, 1);\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = canvas.height = 1;\n    var ctx = canvas.getContext(\"2d\");\n\n    return function (color, alpha) {\n      ctx.clearRect(0,0,1,1);\n      ctx.fillStyle = color;\n      ctx.fillRect(0,0,1,1);\n      var d = ctx.getImageData(0,0,1,1).data;\n      return 'rgba('+[ d[0], d[1], d[2], alpha ]+')';\n    }\n  }());\n\n  /**\n  Converts a CSS color string into an anonymous object with color and alpha\n  properties.\n  @static \n  @method extractColorAndAlpha\n  @param {String} color Color in any CSS format.\n  @return {Object} An anonymous object with the properties color and alpha.\n  The color property is a string in hex format and the alpha property is a\n  number from 0.0 to 1.0, rounded to 3 decimal places.\n  **/\n  var extractColorAndAlpha = cp.extractColorAndAlpha = (function(){\n    //var ctx = createCanvasAnd2dContext('grgba', 1, 1);\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = canvas.height = 1;\n    var ctx = canvas.getContext(\"2d\");\n\n    function toHex (value) { \n      var s = value.toString(16); \n      if(s.length==1) s = \"0\"+s;\n      return s;\n    }\n\n    return function (color) {\n      ctx.clearRect(0,0,1,1);\n      ctx.fillStyle = color;\n      ctx.fillRect(0,0,1,1);\n      var d = ctx.getImageData(0,0,1,1).data;\n      return {\n        color: \"#\"+toHex(d[0])+toHex(d[1])+toHex(d[2]),\n        alpha: Math.round(1000*d[3]/255)/1000\n      };\n    }\n  }());\n\n  /**\n  Merges the properties from the given parameters into the first parameter.\n  @static \n  @method extend\n  @param {Object} mergeInto An object to merge into.\n  @param {Object} mergeFrom* Objects to merge from.\n  **/\n  function extend (extending /* , arg1, arg2, ... */) {\n    for (var a=1, l=arguments.length; a<l; ++a) {\n      var source = arguments[a];\n      if (source) {\n        for (var prop in source)\n          if (source[prop] !== void 0)\n            extending[prop] = source[prop];\n      }\n    }\n  }\n  cp.extend = extend;\n\n  function emptyFn() {};\n  function inherit (cls, base) { // from Box2d\n    var tmpCtr = cls;\n    emptyFn.prototype = base.prototype;\n    cls.prototype = new emptyFn;\n    cls.prototype.constructor = tmpCtr;\n    cls.prototype.__super = base.prototype;\n  }\n  cp.inherit = inherit;\n\n  return cp;\n})({});/* harmony export */ exports[\"a\"] = Illuminated;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./vendors/illuminated.js\n// module id = 5\n// module chunks = 0\n\n//# sourceURL=webpack:///./vendors/illuminated.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector__ = __webpack_require__(1);\n/* harmony export */ exports[\"a\"] = Body;\n\nfunction Body(scene, sprite, boundToCamera = true, speed = 3) {\n  return {\n    movementTo,\n    moveBy\n  };\n\n  function movementTo(target) {\n    let difference = target.subtract(sprite.getCenterVector());\n    // let direction = difference.normalize();\n    // let movement = direction.dotProduct(speed);\n    let deltaX = speed * Math.sign(difference.getX());\n\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__vector__[\"a\" /* Vector */])(deltaX, 0);\n  }\n\n  function moveBy(vector) {\n    if (sprite.right() + vector.getX() > scene.getCanvas().width) { return; }\n\n    sprite.move(vector.getX(), vector.getY());\n    sprite.setFlipped(Math.sign(vector.getX()));\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./body.js\n// module id = 6\n// module chunks = 0\n\n//# sourceURL=webpack:///./body.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__inventoryItem__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tree__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__twig__ = __webpack_require__(11);\n/* harmony export */ exports[\"a\"] = Flint;\n\n\n\n\nfunction Flint(scene) {\n  const inventoryItem = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__inventoryItem__[\"a\" /* InventoryItem */])(\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sprite__[\"a\" /* Sprite */])(scene, './imgs/flint.png', null, null, 50, 50),\n    onUse\n  );\n\n  const flint = Object.assign({}, inventoryItem, {\n    constructor: Flint,\n    trigger\n  });\n\n  return flint;\n\n  function onUse(item, coordinates) {\n    const objects = scene.findObjectsAt(coordinates);\n    const tree = objects.find(object => object.constructor == __WEBPACK_IMPORTED_MODULE_2__tree__[\"a\" /* Tree */]);\n\n    if (tree) {\n      scene.getPlayer().setTarget(\n        tree.getCenterVector(),\n        () => {\n          tree.lightSource.setEnabled(true);\n          scene.getPlayer().setSpeech(\"Let there be light! Hmm, I like the sound of that.\");\n        }\n      );\n    }\n\n    const twig = objects.find(object => object.constructor == __WEBPACK_IMPORTED_MODULE_3__twig__[\"a\" /* Twig */]);\n    if (twig) {\n      twig.ignite();\n    }\n  }\n\n  function trigger(event, coordinates) {\n    inventoryItem.trigger(event, coordinates);\n\n    switch (event) {\n      case 'hover':\n        let actionStatus = 'Use Flint';\n\n        if (flint.isDragging()) {\n          const objectUnderCursor = scene.findObjectsAt(coordinates, true).find(object => object != flint);\n          if (objectUnderCursor) {\n            actionStatus += ` on ${objectUnderCursor.name}`;\n          }\n        }\n\n        scene.setActionStatus(actionStatus);\n\n        break;\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./flint.js\n// module id = 7\n// module chunks = 0\n\n//# sourceURL=webpack:///./flint.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__trigger__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__rock__ = __webpack_require__(9);\n/* harmony export */ exports[\"a\"] = PileOfRocks;\n\n\n\nfunction PileOfRocks(scene, x, y) {\n  const triggerObject = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__trigger__[\"a\" /* Trigger */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sprite__[\"a\" /* Sprite */])(scene, './imgs/pile-of-rocks.png', x, y - 50, 100, 50), (trigger) => {\n    scene.getPlayer().setTarget(\n      trigger.getCenterVector(),\n      () => {\n        if (scene.getInventory().push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__rock__[\"a\" /* Rock */])(scene))) {\n          scene.getPlayer().setSpeech(\"There is not a thing as too many rocks.\");\n        } else {\n          scene.getPlayer().setSpeech(\"I can't carry any more rocks, they are too heavy. :(\");\n        }\n      }\n    );\n  });\n\n  const pileOfRocks = Object.assign({}, triggerObject, {\n    constructor: PileOfRocks,\n    name: 'Pile of Rocks',\n    trigger\n  });\n\n  return pileOfRocks;\n\n  function trigger(event, coordinates) {\n    triggerObject.trigger(event, coordinates);\n\n    switch (event) {\n      case 'hover':\n        scene.setActionStatus('Pick up Rock');\n        break;\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./pileOfRocks.js\n// module id = 8\n// module chunks = 0\n\n//# sourceURL=webpack:///./pileOfRocks.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__inventoryItem__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vector__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__projectile__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__tiger__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pileOfRocks__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__flint__ = __webpack_require__(7);\n/* harmony export */ exports[\"a\"] = Rock;\n\n\n\n\n\n\n\nfunction Rock(scene) {\n  const MAX_DISTANCE = 300;\n  const inventoryItem = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__inventoryItem__[\"a\" /* InventoryItem */])(\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sprite__[\"a\" /* Sprite */])(scene, './imgs/rock.png', null, null, 24, 24),\n    onUse\n  );\n\n  const rock = Object.assign({}, inventoryItem, {\n    constructor: Rock,\n    name: 'Rock',\n    trigger\n  });\n\n  return rock;\n\n  function onUse(item, coordinates) {\n    scene.getInventory().remove(rock);\n\n    let anotherRock = scene\n                        .findObjectsAt(coordinates)\n                        .find(object => object.constructor === Rock && object !== item);\n\n    if (anotherRock) {\n      scene.getInventory().remove(anotherRock);\n      scene.getInventory().push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__flint__[\"a\" /* Flint */])(scene));\n      return;\n    }\n\n    let projectileSprite = item.getSprite().copy();\n    let player = scene.getPlayer();\n    projectileSprite.setCenterX(player.getCenterX());\n    projectileSprite.setCenterY(player.getCenterY() - 50);\n    let difference = coordinates.x - projectileSprite.getCenterX();\n    if (Math.abs(difference) > MAX_DISTANCE) {\n      coordinates.x = projectileSprite.getCenterX() + MAX_DISTANCE * Math.sign(difference);\n    }\n\n    scene.add(\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__projectile__[\"a\" /* Projectile */])(\n        scene,\n        projectileSprite,\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__vector__[\"a\" /* Vector */])(coordinates.x, coordinates.y),\n        (hitObjects) => {\n          //const hitObjects = scene.findObjectsAt(coordinates);\n          const tiger = hitObjects.find(object => object.constructor == __WEBPACK_IMPORTED_MODULE_4__tiger__[\"a\" /* Tiger */]);\n          if (tiger) {\n            player.setSpeech('It hit the eye of the tiger!');\n            tiger.setFleeing();\n          }\n\n          const pileOfRocks = hitObjects.find(object => object.constructor == __WEBPACK_IMPORTED_MODULE_5__pileOfRocks__[\"a\" /* PileOfRocks */]);\n          if (pileOfRocks) {\n            let lightSourcesNearby = scene.lightSourcesInRadius(pileOfRocks.getCenterVector(), 100);\n            lightSourcesNearby.forEach(light => light.setEnabled(true));\n          }\n        }\n      )\n    );\n  }\n\n  function trigger(event, coordinates) {\n    inventoryItem.trigger(event, coordinates);\n\n    switch (event) {\n      case 'hover':\n        scene.setActionStatus(rock.isDragging() ? 'Throw Rock' : 'Use Rock');\n        break;\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./rock.js\n// module id = 9\n// module chunks = 0\n\n//# sourceURL=webpack:///./rock.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__body__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vector__ = __webpack_require__(1);\n/* harmony export */ exports[\"a\"] = Tiger;\n\n\n\nfunction Tiger(scene, x, y, player, lightSources) {\n  const MINIMUM_DISTANCE_TO_FIRE = 140;\n  const height = 100;\n  y -= height;\n  let sprite = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sprite__[\"a\" /* Sprite */])(scene, './imgs/tiger.png', x, y, 160, height, 400, 250, {\n    standing: {\n      frames: [0],\n      speed: 0\n    },\n\n    leaping: {\n      frames: [1, 2],\n      speed: 300,\n      loop: true\n    }\n  });\n  sprite.setAnimation('leaping');\n  let body = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__body__[\"a\" /* Body */])(scene, sprite, false, 6);\n\n  const CHASING = 'chasing';\n  const FLEEING = 'fleeing';\n  let state = CHASING;\n  const fleeTimeout = 2.0 * 1000;\n  let startedFleeing;\n\n  return Object.assign({}, sprite, {\n    constructor: Tiger,\n    name: 'Sabertooth Tiger',\n    update,\n    setFleeing\n  });\n\n  function update(timeElapsed) {\n    switch (state) {\n      case CHASING:\n        chase();\n        break;\n      case FLEEING:\n        flee();\n        break;\n      default: throw new Error(`Unexpected state: ${state}`);\n    }\n\n    sprite.update(timeElapsed);\n  }\n\n  function chase() {\n    let movement = body.movementTo(player.getCenterVector());\n    let newCenter = movement.add(sprite.getCenterVector());\n\n    const closestLightSources = lightSources\n    .filter(light => light.enabled)\n    .sort(\n      (l1, l2) => Math.abs(sprite.getX() - l1.position.x) - Math.abs(sprite.getX() - l2.position.x)\n    );\n\n    const closestLightSource = closestLightSources[0];\n\n    if (closestLightSource) {\n      let lightPosition = new __WEBPACK_IMPORTED_MODULE_2__vector__[\"a\" /* Vector */](closestLightSource.position.x, closestLightSource.position.y);\n      let distance = Math.abs(lightPosition.getX() - newCenter.getX()) - radius(sprite);\n      const difference = MINIMUM_DISTANCE_TO_FIRE - distance;\n      if (difference > 6) {\n        movement = movement.dotProduct(-1);\n        sprite.setAnimation('standing');\n      } else if (difference >= 0) {\n        movement = movement.dotProduct(0);\n        sprite.setAnimation('standing');\n      } else {\n        if (sprite.getAnimation() !== 'leaping') {\n          sprite.setAnimation('leaping');\n        }\n      }\n    }\n\n    body.moveBy(movement);\n    sprite.setFlipped(Math.sign(player.getX() - sprite.getX()));\n  }\n\n  function flee() {\n    if (new Date() - startedFleeing > fleeTimeout) {\n      setChasing();\n    } else {\n      let movement = body.movementTo(player.getCenterVector()).dotProduct(-1);\n      body.moveBy(movement);\n    }\n  }\n\n  function radius(sprite) {\n    return (sprite.getWidth() / 2 + sprite.getHeight() / 2) / 2;\n  }\n\n  function setFleeing() {\n    state = FLEEING;\n    startedFleeing = new Date();\n    saySomething();\n    sprite.setAnimation('leaping');\n  }\n\n  function setChasing() {\n    state = CHASING;\n  }\n\n  function saySomething() {\n    const noises = [\n      \"GROOOWL!\",\n      \"GRRRAAAWR!\",\n      \"meow!\",\n      \"MRRRRGGGGGLLLL!\"\n    ];\n\n    const noise = noises[Math.floor((Math.random() * 10 % noises.length))];\n    sprite.setSpeech(noise);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./tiger.js\n// module id = 10\n// module chunks = 0\n\n//# sourceURL=webpack:///./tiger.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__inventoryItem__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__flint__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tree__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__torch__ = __webpack_require__(16);\n/* harmony export */ exports[\"a\"] = Twig;\n\n\n\n\n\nfunction Twig(scene) {\n  const inventoryItem = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__inventoryItem__[\"a\" /* InventoryItem */])(\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sprite__[\"a\" /* Sprite */])(scene, './imgs/twig.png', null, null, 30, 60),\n    onUse\n  );\n\n  const twig = Object.assign({}, inventoryItem, {\n    constructor: Twig,\n    name: 'Twig',\n    trigger,\n    ignite\n  });\n\n  return twig;\n\n  function onUse(item, coordinates) {\n    const ignitionStarter = scene\n                              .findObjectsAt(coordinates)\n                              .find(object => {\n                                return object.constructor == __WEBPACK_IMPORTED_MODULE_2__flint__[\"a\" /* Flint */] ||\n                                       object.constructor == __WEBPACK_IMPORTED_MODULE_3__tree__[\"a\" /* Tree */] &&\n                                       object.lightSource.enabled;\n                              });\n\n    if (ignitionStarter) {\n      ignite();\n    }\n  }\n\n  function ignite() {\n    scene.getInventory().remove(twig);\n    scene.getInventory().push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__torch__[\"a\" /* Torch */])(scene));\n    scene.getPlayer().setSpeech(\"I am the lightbringer!\");\n  }\n\n  function trigger(event, coordinates) {\n    inventoryItem.trigger(event, coordinates);\n\n    switch (event) {\n      case 'hover':\n        let actionStatus = 'Use Twig';\n\n        if (twig.isDragging()) {\n          const objectUnderCursor = scene.findObjectsAt(coordinates, true).find(object => object != twig);\n          if (objectUnderCursor) {\n            actionStatus += ` on ${objectUnderCursor.name}`;\n          }\n        }\n\n        scene.setActionStatus(actionStatus);\n\n        break;\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./twig.js\n// module id = 11\n// module chunks = 0\n\n//# sourceURL=webpack:///./twig.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__player__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vector__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__inventory__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__inventoryItem__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__rock__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pileOfRocks__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__tiger__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__tree__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__twigTrigger__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__trigger__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__vendors_illuminated__ = __webpack_require__(5);\n/* harmony export */ exports[\"a\"] = Scene;\n\n\n\n\n\n\n\n\n\n\n\nconst { Lamp, Lighting, DarkMask, Vec2 } = __WEBPACK_IMPORTED_MODULE_11__vendors_illuminated__[\"a\" /* Illuminated */];\n\nfunction Scene(canvas) {\n  const scene = {\n    constructor: Scene,\n    update,\n    render,\n    onMouseDown,\n    onMouseMove,\n    findObjectsAt,\n    add,\n    remove,\n    getPlayer,\n    getTiger,\n    getInventory,\n    getCanvas,\n    getLightSources,\n    overlappingObjectsWith,\n    lightSourcesInRadius,\n    setActionStatus\n  };\n\n  const bgMusic = new Audio('./sounds/bgmusic.mp3');\n  bgMusic.loop = true;\n  bgMusic.play();\n\n  const FLOOR = 350;\n  const background = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sprite__[\"a\" /* Sprite */])(scene, './imgs/background.png', 0, 0, canvas.width, canvas.height);\n  const player = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__player__[\"a\" /* Player */])(scene, 600, FLOOR);\n  player.setTarget(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__vector__[\"a\" /* Vector */])(1100, FLOOR));\n  player.setSpeech('AHHHHHHHHH!', 3000);\n\n  const inventory = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__inventory__[\"a\" /* Inventory */])(4);\n  const pilesOfRocks = [\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__pileOfRocks__[\"a\" /* PileOfRocks */])(scene, 1050, FLOOR),\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__pileOfRocks__[\"a\" /* PileOfRocks */])(scene, 700, FLOOR)\n  ];\n\n  const twigTrigger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__twigTrigger__[\"a\" /* TwigTrigger */])(scene, 420, FLOOR + 20);\n\n  const lightSources = [\n    createLightSource(1100, FLOOR - 150),\n    createLightSource(700, FLOOR - 150),\n    createLightSource(500, FLOOR - 150)\n  ];\n  const trees = lightSources.map(light => __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__tree__[\"a\" /* Tree */])(scene, light, light.position.x - 100, light.position.y - 150));\n  trees.forEach(tree => {\n    const lightSource = tree.lightSource;\n    lightSource.isEnabled = () => lightSource.enabled;\n    lightSource.setEnabled = value => {\n      lightSource.enabled = value;\n      tree.setAnimation('burning');\n    }\n  });\n\n  const initialLightSource = lightSources[0];\n  const lightning = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sprite__[\"a\" /* Sprite */])(scene, './imgs/lightning.png', 1050, 0, 100, 300);\n  let lightningFinishedAt;\n  const lightningDuration = 500;\n  let actionStatus = 'Walk to';\n\n  //let lightings = [\n  //  new Lighting({\n  //    light: lightSources[0],\n  //    objects: []\n  //  }),\n  //];\n\n  let darkmask = new DarkMask({\n    lights: lightSources,\n    color: 'rgba(0,0,0,0.7)'\n  })\n\n  const tiger = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__tiger__[\"a\" /* Tiger */])(scene, 0, FLOOR + 20, player, lightSources);\n\n  let targets = [twigTrigger].concat(pilesOfRocks);\n  let objects = trees.concat(pilesOfRocks).concat([twigTrigger, player, tiger]);\n\n  return scene;\n\n  function update(timeElapsed) {\n    if (\n      !initialLightSource.isEnabled() &&\n      Math.abs(initialLightSource.position.x - player.getCenterX()) < 100\n    ) {\n      initialLightSource.setEnabled(true);\n      player.setSpeech(\"WOW! Sun, is that you?\");\n      lightningFinishedAt = Date.now() + lightningDuration;\n    }\n\n    inventory.concat(objects).forEach(object => object.update(timeElapsed));\n\n    let distance = 120 + Math.sin(Date.now() * 0.001) * 10;\n    lightSources.filter(light => light.enabled).forEach(light => light.distance = distance);\n  }\n\n  function render(context) {\n    if (player.getX() < 100) {\n      context.fillStyle = \"black\";\n      context.fillRect(0, 0, canvas.width, canvas.height);\n\n      context.font = \"14px Monospace\";\n      context.fillStyle = \"white\";\n      const gameOverMessage = \"And so he discovered fire and changed the world...\";\n      context.fillText(gameOverMessage, canvas.width / 2 - gameOverMessage.length / 2 * 14, canvas.height / 2 - 7);\n\n      return;\n    }\n\n    background.render(context);\n    objects.forEach(sprite => sprite.render(context));\n\n    if (lightningFinishedAt) {\n      if (Date.now() <= lightningFinishedAt) {\n        lightning.render(context);\n      }\n    }\n\n    //lightings.forEach(lighting => lighting.compute(context.canvas.width, context.canvas.height));\n    darkmask.compute(context.canvas.width, context.canvas.height);\n\n    renderLights(context);\n    renderDark(context);\n\n    inventory.forEach((item) => item.render(context));\n\n    context.font = \"14px Monospace\";\n    context.fillStyle = \"white\";\n    context.fillText(actionStatus, canvas.width / 2 - (actionStatus.length / 2) * 14, 250);\n\n    objects.forEach(object => object.renderUI(context));\n\n    if (window.DEBUG) {\n      context.save();\n\n      context.font = \"14px Monospace\";\n      context.fillStyle = \"white\";\n      context.fillText(\"Player: \" + player.getCenterVector().toString(), 10, 25);\n\n      context.font = \"14px Monospace\";\n      context.fillStyle = \"white\";\n      context.fillText(\"Tiger: \" + tiger.getCenterVector().toString(), 10, 40);\n\n      context.restore();\n    }\n  }\n\n  function onMouseDown(coordinates) {\n    let dragged = inventory.find(item => item.isDragging());\n    if (dragged) {\n      dragged.trigger('drop', coordinates);\n    } else {\n      let clicked = findObjectsAt(coordinates).filter(object => object.clickable)[0];\n      if (clicked) {\n        clicked.trigger('click', coordinates);\n      } else {\n        player.onMouseDown(coordinates);\n      }\n    }\n  }\n\n  function onMouseMove(coordinates) {\n    setActionStatus('Walk to');\n\n    inventory\n      .concat(objects)\n      .filter((target) => target.contains(coordinates))\n      .forEach(object => object.trigger('hover', coordinates));\n\n    inventory\n      .concat(objects)\n      .forEach(object => object.trigger('mousemove', coordinates));\n  }\n\n  function renderLights(context) {\n    context.save();\n    context.globalCompositeOperation = \"lighter\";\n\n    // TODO: Make it work with the lightings to be able to cast shadows\n    lightSources.filter(light => light.enabled).forEach((lightSource) => {\n      lightSource.render(context);\n    });\n    context.restore();\n  }\n\n  function renderDark(context) {\n    context.save();\n    context.globalCompositeOperation = \"source-over\";\n    darkmask.render(context);\n    context.restore();\n  }\n\n  function createLightSource(x, y, enabled = false) {\n    return new Lamp({\n      position: new Vec2(x, y),\n      distance: 0,\n      color: 'rgba(250,220,100,0.8)',\n      enabled\n    });\n  }\n\n  function findObjectsAt(coordinates, includePlayer = false) {\n    return inventory\n             .concat(objects)\n             .filter(object => includePlayer || object !== player)\n             .filter(object => object.contains(coordinates));\n  }\n\n  function add(object) {\n    objects = objects.concat([object]);\n  }\n\n  function remove(object) {\n    objects = objects.filter(obj => !obj.isEqual(object));\n  }\n\n  function getPlayer() { return player; };\n  function getTiger() { return tiger; };\n  function getInventory() { return inventory; }\n  function getCanvas() { return canvas; }\n  function getLightSources() { return lightSources; }\n\n  function overlappingObjectsWith(sprite) {\n    return objects.filter(object => object.overlaps(sprite));\n  }\n\n  function lightSourcesInRadius(position, radius) {\n    return lightSources.filter(\n      light => Math.abs(light.position.x - position.getX()) <= radius\n    );\n  }\n\n  function setActionStatus(newActionStatus) {\n    actionStatus = newActionStatus;\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./scene.js\n// module id = 12\n// module chunks = 0\n\n//# sourceURL=webpack:///./scene.js?");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony export */ exports[\"a\"] = Inventory;function Inventory(maxItems) {\n  let items = [];\n\n  return {\n    push,\n    concat,\n    find,\n    remove,\n    forEach\n  };\n\n  function push(item) {\n    if (items.length < maxItems) {\n      items = items.concat([item]);\n      calculateIndexes();\n      return true;\n    }\n  }\n\n  function concat(array) {\n    return [].concat(array).concat(items);\n  }\n\n  function find(fn) {\n    return items.find(fn);\n  }\n\n  function remove(item) {\n    items = items.filter(i => i !== item);\n    calculateIndexes();\n  }\n\n  function calculateIndexes() {\n    items.forEach((item, index) => item.setIndex(index));\n  }\n\n  function forEach(fn) {\n    return items.forEach(fn);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./inventory.js\n// module id = 13\n// module chunks = 0\n\n//# sourceURL=webpack:///./inventory.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vector__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__body__ = __webpack_require__(6);\n/* harmony export */ exports[\"a\"] = Player;\n\n\n\nfunction Player(scene, x, y) {\n  const MINIMUM_DISTANCE_TO_TIGER = 100;\n  const height = 80;\n  y -= height;\n  let sprite = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sprite__[\"a\" /* Sprite */])(scene, './imgs/caveman.png', x, y, 60, height, 150, 200, {\n    standing: {\n      frames: [0],\n      speed: 0\n    },\n    running: {\n      frames: [0, 1],\n      speed: 500,\n      loop: true\n    }\n  });\n  sprite.setAnimation('running');\n  let body = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__body__[\"a\" /* Body */])(scene, sprite);\n  let target, destinationCallback;\n\n  return Object.assign({}, sprite, {\n    constructor: Player,\n    name: 'Myself',\n    update,\n    render,\n    onMouseDown,\n    trigger,\n    setTarget\n  });\n\n  function update(timeElapsed) {\n    let distanceToTiger = scene.getTiger().getCenterVector().subtract(sprite.getCenterVector());\n    if (distanceToTiger.magnitude() <= MINIMUM_DISTANCE_TO_TIGER) {\n      setTarget(sprite.getCenterVector().add(\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__vector__[\"a\" /* Vector */])(\n          MINIMUM_DISTANCE_TO_TIGER * Math.sign(-distanceToTiger.getX()),\n          0\n        )\n      ));\n      if (!sprite.getSpeech()) {\n        sprite.setSpeech('AHHHHHHHHH!');\n      }\n    }\n\n    if (target) {\n      if (Math.abs(target.subtract(sprite.getCenterVector()).getX()) < 2.0) {\n        destinationCallback && destinationCallback();\n        setTarget();\n      } else {\n        body.moveBy(body.movementTo(target));\n      }\n\n      if (sprite.getAnimation() == 'standing') {\n        sprite.setAnimation('running');\n      }\n    } else {\n      sprite.setAnimation('standing');\n    }\n\n    sprite.update(timeElapsed);\n  }\n\n  function render(context) {\n    sprite.render(context);\n  }\n\n  function onMouseDown(coordinates) {\n    setTarget(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__vector__[\"a\" /* Vector */])(coordinates.x, coordinates.y));\n  }\n\n  function trigger() {}\n\n  function setTarget(newTarget, newDestinationCallback) {\n    target = newTarget;\n    destinationCallback = newDestinationCallback;\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./player.js\n// module id = 14\n// module chunks = 0\n\n//# sourceURL=webpack:///./player.js?");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tree__ = __webpack_require__(3);\n/* harmony export */ exports[\"a\"] = Projectile;\n\nfunction Projectile(scene, sprite, target, onHit) {\n  let x1 = sprite.getX(),\n      y1 = sprite.getY(),\n      x2 = target.getX(),\n      y2 = target.getY();\n\n  let distance = Math.abs(x2 - x1);\n  let speedX = 10 * Math.sign(x2 - x1);\n  let time = Math.abs(distance / speedX);\n  let gravity = 1;\n  let speedY = - time * gravity / 2;\n\n  const projectile = Object.assign({}, sprite, {\n    constructor: Projectile,\n    update\n  });\n\n  return projectile;\n\n  function update(timeElapsed) {\n    let hitObjects = scene.overlappingObjectsWith(sprite).filter(object => {\n      return !object.isEqual(projectile) &&\n             !object.isEqual(scene.getPlayer()) &&\n             object.constructor !== __WEBPACK_IMPORTED_MODULE_0__tree__[\"a\" /* Tree */];\n    });\n\n    if (hitObjects.length || sprite.bottom() >= target.getY()) {\n      onHit(hitObjects);\n      sprite.destroy();\n      return;\n    }\n    sprite.move(speedX, speedY);\n    speedY += gravity;\n\n    sprite.update(timeElapsed);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./projectile.js\n// module id = 15\n// module chunks = 0\n\n//# sourceURL=webpack:///./projectile.js?");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__inventoryItem__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vendors_illuminated__ = __webpack_require__(5);\n/* harmony export */ exports[\"a\"] = Torch;\n\n\nconst { Lamp, Lighting, DarkMask, Vec2 } = __WEBPACK_IMPORTED_MODULE_2__vendors_illuminated__[\"a\" /* Illuminated */];\n\nfunction Torch(scene) {\n  const inventoryItem = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__inventoryItem__[\"a\" /* InventoryItem */])(\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sprite__[\"a\" /* Sprite */])(scene, './imgs/torch.png', null, null, 30, 60, 30, 60, {\n      burning: {\n        frames: [0, 1],\n        speed: 500,\n        loop: true\n      }\n    }),\n    onUse\n  );\n  inventoryItem.setAnimation('burning');\n\n  const torch = Object.assign({}, inventoryItem, {\n    constructor: Torch,\n    update\n  });\n\n  const player = scene.getPlayer();\n  const lightSource = new Lamp({\n    position: new Vec2(player.getCenterX(), player.getCenterY()),\n    distance: 0,\n    color: 'rgba(250,220,100,0.8)',\n    enabled: true\n  });\n\n  scene.getLightSources().push(lightSource);\n\n  return torch;\n\n  function onUse(item, coordinates) {}\n\n  function update() {\n    lightSource.position.x = player.getCenterX();\n    lightSource.position.y = player.getCenterY();\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./torch.js\n// module id = 16\n// module chunks = 0\n\n//# sourceURL=webpack:///./torch.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__trigger__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sprite__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__twig__ = __webpack_require__(11);\n/* harmony export */ exports[\"a\"] = TwigTrigger;\n\n\n\nfunction TwigTrigger(scene, x, y) {\n  const triggerObject = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__trigger__[\"a\" /* Trigger */])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sprite__[\"a\" /* Sprite */])(scene, './imgs/twig.png', x, y - 50, 30, 60), (item) => {\n    scene.getPlayer().setTarget(\n      item.getCenterVector(),\n      () => {\n        scene.remove(twigTrigger);\n        scene.getInventory().push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__twig__[\"a\" /* Twig */])(scene));\n        scene.getPlayer().setSpeech(\"I twig that this may be useful.\");\n      }\n    );\n  });\n  triggerObject.setRotation(90);\n\n  const twigTrigger = Object.assign({}, triggerObject, {\n    constructor: TwigTrigger,\n    name: 'Twig',\n    trigger\n  });\n\n  return twigTrigger;\n\n  function trigger(event) {\n    triggerObject.trigger(event);\n\n    switch (event) {\n      case 'hover':\n        scene.setActionStatus('Pick up Twig');\n        break;\n    }\n  }\n}\nwindow.angle = 0;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./twigTrigger.js\n// module id = 17\n// module chunks = 0\n\n//# sourceURL=webpack:///./twigTrigger.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scene__ = __webpack_require__(12);\n\n\nwindow.DEBUG = false;\nconst canvas = document.getElementById('root');\nconst context = canvas.getContext('2d');\nconst scene = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__scene__[\"a\" /* Scene */])(canvas);\nconst framesPerSecond = 30;\nconst frameRate = 1000 / framesPerSecond;\n\nlet nextFrame = Date.now() + frameRate;\nfunction gameLoop() {\n  let now = Date.now();\n  if (now > nextFrame) {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    scene.update();\n    scene.render(context);\n\n    nextFrame += frameRate;\n  }\n\n  window.requestAnimationFrame(window.gameLoop);\n}\n\nwindow.gameLoop = gameLoop;\ncanvas.addEventListener(\"mousedown\", onMouseDown, false);\ncanvas.addEventListener('mousemove', onMouseMove, false);\ngameLoop();\n\nfunction onMouseDown(event) {\n  scene.onMouseDown(getMousePos(canvas, event));\n}\n\nfunction onMouseMove(event) {\n  scene.onMouseMove(getMousePos(canvas, event));\n}\n\nfunction getMousePos(canvas, event) {\n  const rect = canvas.getBoundingClientRect();\n  return {\n    x: event.clientX - rect.left,\n    y: event.clientY - rect.top\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bootstrap.js\n// module id = 18\n// module chunks = 0\n\n//# sourceURL=webpack:///./bootstrap.js?");

/***/ }
/******/ ]);